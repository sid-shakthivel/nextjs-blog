---
title: 'Multitasking'
date: '2021-06-21'
---

The next feature a kernel needs is multitasking. In this article, you'll first learn about multitasking, multithreading, and multiprocessing, and the difference between all of them, timers, and context switching.

Firstly, a thread is simply code in a program that can be executed independently from other code. Javascript for example is a single threaded language, while languages like java can have multiple threads. Multithreading is where you have multiple threads in the same program that can execute in parallel. Of course one CPU core can only do one thing at a time, this means that computer switches threads so fast it seems to be doing multiple things at the same time while in reality it isn't. In other words each thread receives a bit of time. A process is an instance of a program made up of threads. An example of a process is discord, or chrome. Multitasking is very similar to multithreading. We'll be looking at pre-emptive multitasking in particular. CPU time is divided for programs and the execution of programs are swapped after the time given ends. It's important to note that programs that are demanding to get the most time from the CPU do get the most time; for example if you're editing a video on final cut pro, chrome might seem a bit slow.

So what does the pre-emptive in pre-emptive multitasking mean? It basically means we seize control of the CPU time, and give it from one task to another task for some time. How do we know how much time to give a process? Well Interrupt 33 is for a timer. All we need to do is setup the timer - this means that for some time interval (which you set), an interrupt will be called. In this timer interrupt handler, we need to do 2 things save the state of the current task and decide what task should go next. But wait - how and where do we save the `state` of a task? Well I have a process struct. It has it's own stack of about 1 page(Pointer to where we are in the stack), the name, and status of the task. The stack is where we will preserve the state and for the process to actually use. It's important to know what happens when an interrupt is called - SS register, ESP register, EFLAGS, CS register, and EIP register are pushed onto the stack. What I do is setup the stacks of each process to already have these values so when I switch process I can just pop this all of the stack. Note that the EIP register should contain the address of the code your process should run. A context switch is just saving the state of a process this often involves switching stacks. Whenever the timer interrupt is called, I push general registers, save the the ESP, swap stacks (by changing the ESP register to point to another process' stack), then pop registers, and iret. The iret returns from a interrupt and will send us to where the code you want to execute for a process is. Note that when we preempt a task it will always be in the same state with the iret stack and general registers being pushed onto it.

Well that is roughly how to setup multitasking! If you wish to see exactly how I did multitasking check out my kernel: https://github.com/sid-shakthivel/SidOS/tree/main/kernel.
